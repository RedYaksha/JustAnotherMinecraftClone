//
//  lines.metal
//  MetalTutorial
//
//  Created by Ronnin Padilla on 8/20/24.
//
#include <metal_stdlib>
#include <metal_matrix>
using namespace metal;
#include "VertexDataTypes.hpp"

struct VertexOut {
    float4 position [[position]];
    float3 color;
    float4 posNDC;
};

vertex VertexOut lineVS(uint vertexID [[vertex_id]],
                        uint instanceID [[instance_id]],
                        constant LineVertexData* vertexData [[buffer(0)]],
                        constant CameraData* cd [[buffer(1)]],
                        constant LineData* lineData[[buffer(2)]]
                       )
{
    // turns out not needed to render a line-quad (since the quad won't depict a line if its rotated towards us.)
    // but what it really needs is to rotate towards the camera by rotating along the line's axis.
    // https://stackoverflow.com/questions/61559585/how-to-remove-rotation-from-model-view-matrix-so-that-object-always-faces-camera
    /*
    matrix_float4x4 v = td->view;
    float3x3 ff(v[0].xyz, v[1].xyz, v[2].xyz);
    float3x3 inv = transpose(ff);
    */
    
    LineData myLineData = lineData[instanceID];
    LineVertexData vd = vertexData[vertexID];
    
    float3 unitZ(1,0,0);
    
    VertexOut out;
    out.position = cd->projection * cd->view * myLineData.transform * vd.position;
    out.color = myLineData.color;
    out.posNDC = out.position;
    
    //float4x4 t = td->model;
    
    // BUG: index 0 of transforms is returning wrong values
    // for whatever reason, (transforms[0])[1].xyz == (0,0,0)
    // even if that's not what's uploaded
    //
    // Minimum constant buffer offset alignment?? for constant address space in vertex shader
    // it says 4B
    //

    return out;
}

struct LineFragmentOut {
    // According to the Metal API:
    // If the depth value is not output by the fragment function, the depth value generated by the rasterizer
    // is output to the depth attachment.
    //
    float4 color [[color(0)]];
    // By specifying this to any, greater, or less, we can fill in custom values to the depth buffer ourselves.
    //float depth [[depth(less)]];
};

fragment float4 lineFS(VertexOut in [[stage_in]]) {
    LineFragmentOut out;
    out.color = float4(in.color, 1.0f);
    
    // store linear depth into w-component
    float3 projCoords = in.posNDC.xyz / in.posNDC.w;
    //out.depth = projCoords.z;
    
    return float4(in.color, 1.0f);
}
