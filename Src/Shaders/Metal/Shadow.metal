//
//  shadow.metal
//  MetalTutorial
//
//  Created by Ronnin Padilla on 8/16/24.
//
#include <metal_stdlib>
using namespace metal;
#include "VertexDataTypes.hpp"

struct ShadowVSOut {
    float4 position [[position]];
};

struct VertexOut {
    float4 position [[position]];
    float4 positionWS;
};

struct ShadowFragmentOut {
    // According to the Metal API:
    // If the depth value is not output by the fragment function, the depth value generated by the rasterizer
    // is output to the depth attachment.
    //
    // By specifying this to any, greater, or less, we can fill in custom values to the depth buffer ourselves.
    float depth [[depth(less)]];
};

vertex VertexOut voxelShadowPassVS(uint vertexID [[vertex_id]],
                                   constant VertexData* vertexData [[buffer(0)]],
                                   constant CameraData* cd [[buffer(1)]]) {
    VertexOut out;
    out.position = cd->projection * cd->view * vertexData[vertexID].position;
    
    // set this to an already transformed position so we can perform
    // perspective divide in the fragment shader and set
    // d = (position.xyz / position.w).z // [-1,1]
    // outDepth = d * 0.5 + 0.5 // [0,1]
    out.positionWS = out.position;
    
    return out;
}

vertex VertexOut skeletalMeshShadowPassVS(uint vertexID [[vertex_id]],
                            constant SkeletalMeshVertexData* vertexData [[buffer(0)]],
                            constant float4x4* boneTransforms [[buffer(1)]],
                            constant float4x4* modelTransforms [[buffer(2)]],
                            constant ObjectData* objectData [[buffer(3)]],
                            constant CameraData* cd [[buffer(4)]]
                            )
{
    auto meshVertex = vertexData[vertexID];
    
    // meshVertex.position.w is the only place where it should be one,
    // as we transform it with various matrices, the translation will
    // not work as expected if we modify the w-component
    float4 modelPos = modelTransforms[meshVertex.transformationIndex] * meshVertex.position;
    
    // Note: w-component must start as ZERO!!!
    float4 pos = float4(0,0,0,0);
    
    for(int i = 0; i < 4; i++) {
        const VertexBoneWeight bw = meshVertex.boneWeights[i];
        if(bw.boneIndex == -1) {
            continue;
        }
        float4 localPos = boneTransforms[bw.boneIndex] * modelPos;
        pos += bw.weight * localPos;
    }
    
    float4 posWS = objectData->model * pos;
    
    VertexOut out;
    out.position = cd->projection * cd->view * posWS;
    out.positionWS = out.position;

    return out;
}

fragment ShadowFragmentOut shadowPassFS(VertexOut in [[stage_in]]) {
    ShadowFragmentOut out;
    
    // The metal rasterizer fills in a logarithmic depth value [0,1]
    // representing depth from the near and far plane.
    // Since we cannot replicate this function for shadow mapping,
    // we use a linear depth value so we can do a consistent
    // comparison check at the shadow mapping stage in the light pass.
    float3 projCoords = in.positionWS.xyz / in.positionWS.w;
    projCoords = projCoords * 0.5 + float3(0.5, 0.5, 0.5);
    
    out.depth = projCoords.z;
    return out;
}
